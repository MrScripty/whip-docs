<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulkan 2D Rendering Engine Hierarchy</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #F5F4F2;
            color: #333333;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        h1 {
            text-align: center;
            color: #637C8A;
            margin: 20px 0;
            font-weight: 300;
            padding: 0 15px;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto 20px auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border-radius: 8px;
            flex-direction: row;
        }
        .tree-column {
            flex: 1;
            overflow-y: auto;
            background-color: #ffffff;
            border-right: 1px solid #e0e0e0;
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
            padding: 0;
            position: relative;
        }
        .combined-sticky-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #ffffff;
            width: 100%;
        }
        .branch-indicator-bar-area {
            position: absolute;
            top: 20px; /* Match tree-content-wrapper padding-top */
            left: 0;
            width: 8px;
            flex-shrink: 0;
            background-color: #ffffff;
            z-index: 9;
            /* Height is set by JS to match treeContentWrapper.scrollHeight */
        }
        .bar-segment {
            position: absolute;
            width: 100%;
            left: 0;
            transition: top 0.15s ease-out, height 0.15s ease-out;
        }
        .sticky-headers-container {
            flex-grow: 1;
        }
        .sticky-header-item {
            box-sizing: border-box;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            overflow: hidden;
            width: 100%;
            /* Height and padding-left set by JS */
        }
        .tree-content-wrapper {
            padding-top: 20px;
            padding-right: 20px;
            padding-bottom: 20px;
            padding-left: 8px; /* Space for the bar */
            position: relative;
        }
        .tree-content-wrapper > ul {
            list-style: none;
            padding-left: 10px; /* 10px gap after the bar */
            margin: 0;
        }
        .tree-content-wrapper ul ul {
            padding-left: 20px;
        }
        .info-column {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }
        .info-tags-bar {
            display: flex;
            margin-bottom: 8px;
            padding: 2px;
            background-color: #4F5B66;
            border-radius: 4px;
            min-height: 24px;
            box-sizing: border-box;
            align-items: center;
        }
        .tag-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: 500;
            color: #ffffff;
            display: none;
        }
        .tag-badge.tag-required { background-color: #16c59d; }
        .tag-badge.tag-optional { background-color: #BA8675; }
        .tag-badge.tag-advanced { background-color: #FA855F; }
        .tag-badge.tag-other { background-color: #76A59A; }
        .info-links-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 6px 8px;
            background-color: #e9edf0;
            border-radius: 4px;
            min-height: 28px;
            box-sizing: border-box;
            align-items: center;
        }
        .info-link {
            display: none;
            align-items: center;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.85em;
            text-decoration: none;
            color: #337ab7;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
        }
        .info-link:hover {
            background-color: #e7e7e7;
            text-decoration: underline;
        }
        .info-link .external-link-icon {
            margin-left: 5px;
            font-size: 0.9em;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                margin: 0 10px 20px 10px;
                max-width: none;
            }
            .tree-column {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                border-radius: 8px 8px 0 0;
                max-height: 45vh;
            }
            .info-column {
                border-radius: 0 0 8px 8px;
                max-height: 45vh;
            }
            .info-tags-bar {
                padding: 2px;
                min-height: 22px;
                margin-bottom: 6px;
            }
            .tag-badge {
                padding: 2px 6px;
                font-size: 0.75em;
            }
            .info-links-bar {
                padding: 4px 6px;
                gap: 8px;
                margin-bottom: 10px;
            }
            .info-link {
                font-size: 0.8em;
            }
        }
        #info-text {
            flex: 1;
            background: none;
            border: 1px solid #dddddd;
            color: #637C8A;
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            font-size: 14px;
            padding: 15px;
            resize: none;
            outline: none;
            border-radius: 4px;
            line-height: 1.6;
            min-height: 100px;
        }
        .tree-content-wrapper li {
            position: relative;
            padding: 0;
            cursor: default;
            user-select: none;
            margin-bottom: 1px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .tree-item-row {
            display: flex;
            align-items: center;
            padding: 4px 0;
            position: relative;
            z-index: 2;
        }
        .tree-content-wrapper ul ul > li > .tree-item-row::before {
            content: "";
            position: absolute;
            left: -12px;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #cccccc;
        }
        .tree-content-wrapper ul ul > li:last-child > .tree-item-row::before {
            height: 15px;
        }
        .tree-content-wrapper ul ul > li > .tree-item-row::after {
            content: "";
            position: absolute;
            left: -12px;
            top: 14px;
            width: 10px;
            height: 1px;
            background-color: #cccccc;
        }
        .tree-content-wrapper > ul > li > .tree-item-row::before,
        .tree-content-wrapper > ul > li > .tree-item-row::after {
            display: none;
        }
        .tree-item-content {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #333333;
        }
        .tree-content-wrapper li .tree-item-row:not(.parent-highlight-li-row):not(.selected-item-dark-li-row):hover > .tree-item-content {
            background-color: #e9f5ff;
        }
        .tree-toggle {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            font-family: monospace;
            font-weight: bold;
            color: #637C8A;
            margin-right: 4px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .tree-toggle:hover {
            background-color: #d0e0f0;
        }
        .tree-item-content.essential-text { color: #16c59d; }
        .tree-item-content.secondary-text { color: #BA8675; }
        .tree-item-content.advanced-text { color: #FA855F; }
        .tree-item-content.other-text { color: #76A59A; }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row {
            background-color: #e6ffe6;
        }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row:hover {
            background-color: #d9ffd9;
        }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row > .tree-item-content.essential-text { color: #16c59d; }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row > .tree-item-content.secondary-text { color: #BA8675; }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row > .tree-item-content.advanced-text { color: #FA855F; }
        .tree-content-wrapper li.parent-highlight-li > .tree-item-row > .tree-item-content.other-text { color: #76A59A; }
        .tree-content-wrapper li.selected-item-dark-li > .tree-item-row {
            background-color: #637C8A !important;
        }
        .tree-content-wrapper li.selected-item-dark-li > .tree-item-row > .tree-item-content {
            color: #ffffff !important;
            font-weight: 500;
        }
        .tree-content-wrapper li.selected-item-dark-li > .tree-item-row:hover {
            background-color: #526570 !important;
        }
        .tree-column::-webkit-scrollbar,
        .info-column::-webkit-scrollbar { width: 8px; }
        .tree-column::-webkit-scrollbar-track,
        .info-column::-webkit-scrollbar-track { background: #ececec; border-radius: 10px; }
        .tree-column::-webkit-scrollbar-thumb,
        .info-column::-webkit-scrollbar-thumb { background-color: #b0b0b0; border-radius: 10px; border: 2px solid #ececec; }
        .tree-column::-webkit-scrollbar-thumb:hover,
        .info-column::-webkit-scrollbar-thumb:hover { background-color: #637C8A; }
        .tree-column,
        .info-column { scrollbar-width: thin; scrollbar-color: #b0b0b0 #ececec; }
    </style>
</head>
<body>
    <h1>Vulkan 2D Rendering Engine Hierarchy</h1>
    <div class="container">
        <div class="tree-column">
            <div class="combined-sticky-header">
                <div class="sticky-headers-container">
                    <!-- Single sticky header item (path text) will be injected here -->
                </div>
            </div>
            <div class="tree-content-wrapper">
                <div class="branch-indicator-bar-area">
                    <!-- Bar segments will be injected here by JavaScript -->
                </div>
                <ul>
                    <li class="essential" data-component="Vulkan API">Vulkan API
                        <ul>
                            <li class="essential" data-component="Instance">Instance
                                <ul>
                                    <li class="secondary" data-component="Validation Layers">Validation Layers</li>
                                    <li class="secondary" data-component="Debug Utilities (VK_EXT_debug_utils)">Debug Utilities (VK_EXT_debug_utils)</li>
                                    <li class="essential" data-component="Instance Extensions">Instance Extensions
                                        <ul>
                                            <li class="essential" data-component="VK_KHR_surface">VK_KHR_surface</li>
                                            <li class="secondary" data-component="VK_EXT_debug_utils (Instance Extension)">VK_EXT_debug_utils (Instance Extension)</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Physical Devices">Physical Devices
                                        <ul>
                                            <li class="essential" data-component="Device Features">Device Features</li>
                                            <li class="essential" data-component="Device Extensions">Device Extensions
                                                <ul>
                                                    <li class="essential" data-component="VK_KHR_swapchain">VK_KHR_swapchain</li>
                                                    <li class="secondary" data-component="VK_KHR_multisampling">VK_KHR_multisampling</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Logical Device">Logical Device
                                <ul>
                                    <li class="essential" data-component="Queues">Queues
                                        <ul>
                                            <li class="essential" data-component="Graphics Queue">Graphics Queue</li>
                                            <li class="essential" data-component="Present Queue">Present Queue</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Command Pools">Command Pools</li>
                                    <li class="other" data-component="Memory Management">Memory Management
                                        <ul>
                                            <li class="other" data-component="Vulkan Memory Allocator (vk-mem)">Vulkan Memory Allocator (vk-mem)</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Surface">Surface
                                <ul>
                                    <li class="essential" data-component="VkSurfaceKHR (Platform-specific, e.g., Win32, XCB)">VkSurfaceKHR (Platform-specific, e.g., Win32, XCB)</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Swapchain">Swapchain
                                <ul>
                                    <li class="essential" data-component="Swapchain Images">Swapchain Images</li>
                                    <li class="essential" data-component="Image Views (Swapchain)">Image Views (Swapchain)</li>
                                    <li class="essential" data-component="Framebuffers">Framebuffers</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Render Pass">Render Pass
                                <ul>
                                    <li class="essential" data-component="Attachments">Attachments
                                        <ul>
                                            <li class="essential" data-component="Color Attachment (Swapchain Image)">Color Attachment (Swapchain Image)</li>
                                            <li class="secondary" data-component="Depth/Stencil Attachment">Depth/Stencil Attachment</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Subpasses">Subpasses</li>
                                    <li class="essential" data-component="Dependencies">Dependencies</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Descriptor Set Layouts">Descriptor Set Layouts
                                <ul>
                                    <li class="essential" data-component="Descriptor Pools">Descriptor Pools</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Pipeline">Pipeline
                                <ul>
                                    <li class="essential" data-component="Shader Modules">Shader Modules
                                        <ul>
                                            <li class="essential" data-component="Vertex Shader (2D transformations)">Vertex Shader (2D transformations)</li>
                                            <li class="essential" data-component="Fragment Shader (Texture sampling, color)">Fragment Shader (Texture sampling, color)</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Pipeline Layout">Pipeline Layout
                                        <ul>
                                            <li class="essential" data-component="Descriptor Sets">Descriptor Sets</li>
                                            <li class="essential" data-component="Push Constants (Transformations, colors)">Push Constants (Transformations, colors)</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Graphics State">Graphics State
                                        <ul>
                                            <li class="essential" data-component="Vertex Input (2D geometry)">Vertex Input (2D geometry)</li>
                                            <li class="essential" data-component="Rasterization">Rasterization</li>
                                            <li class="essential" data-component="Color Blending (Alpha blending)">Color Blending (Alpha blending)</li>
                                            <li class="secondary" data-component="Depth/Stencil Testing">Depth/Stencil Testing</li>
                                            <li class="secondary" data-component="Multisampling">Multisampling</li>
                                            <li class="secondary" data-component="Dynamic State (Viewport, Scissor)">Dynamic State (Viewport, Scissor)</li>
                                        </ul>
                                    </li>
                                    <li class="secondary" data-component="Pipeline Cache">Pipeline Cache</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Resources">Resources
                                <ul>
                                    <li class="essential" data-component="Buffers">Buffers
                                        <ul>
                                            <li class="essential" data-component="Vertex Buffer (2D geometry)">Vertex Buffer (2D geometry)</li>
                                            <li class="essential" data-component="Index Buffer (Triangles/Quads)">Index Buffer (Triangles/Quads)</li>
                                            <li class="essential" data-component="Uniform Buffer (Transformations, colors)">Uniform Buffer (Transformations, colors)</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Images">Images
                                        <ul>
                                            <li class="essential" data-component="Texture Images (Sprites, Atlas)">Texture Images (Sprites, Atlas)</li>
                                            <li class="essential" data-component="Image Views (General Textures)">Image Views (General Textures)</li>
                                            <li class="secondary" data-component="Depth/Stencil Image">Depth/Stencil Image</li>
                                        </ul>
                                    </li>
                                    <li class="essential" data-component="Samplers (Texture sampling)">Samplers (Texture sampling)</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Synchronization">Synchronization
                                <ul>
                                    <li class="essential" data-component="Semaphores (Image acquisition, rendering)">Semaphores (Image acquisition, rendering)</li>
                                    <li class="essential" data-component="Fences (CPU-GPU sync)">Fences (CPU-GPU sync)</li>
                                    <li class="secondary" data-component="Events">Events</li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Command Buffers">Command Buffers
                                <ul>
                                    <li class="essential" data-component="Primary Command Buffers">Primary Command Buffers</li>
                                    <li class="secondary" data-component="Secondary Command Buffers">Secondary Command Buffers</li>
                                    <li class="essential" data-component="Recording Operations">Recording Operations
                                        <ul>
                                            <li class="essential" data-component="Bind Pipeline">Bind Pipeline</li>
                                            <li class="essential" data-component="Bind Descriptor Sets">Bind Descriptor Sets</li>
                                            <li class="essential" data-component="Bind Vertex/Index Buffers">Bind Vertex/Index Buffers</li>
                                            <li class="essential" data-component="Draw Commands">Draw Commands</li>
                                            <li class="essential" data-component="Image Layout Transitions">Image Layout Transitions</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="essential" data-component="Pipeline Barriers">Pipeline Barriers
                                <ul>
                                    <li class="essential" data-component="Pipeline Stages (Vertex, Fragment)">Pipeline Stages (Vertex, Fragment)</li>
                                    <li class="essential" data-component="Memory Barriers">Memory Barriers</li>
                                </ul>
                            </li>
                            <li class="advanced" data-component="Advanced Features">Advanced Features
                                <ul>
                                    <li class="advanced" data-component="Post-Processing">Post-Processing
                                        <ul>
                                            <li class="advanced" data-component="Render Targets">Render Targets</li>
                                            <li class="advanced" data-component="Compute Shaders">Compute Shaders</li>
                                        </ul>
                                    </li>
                                    <li class="advanced" data-component="Sparse Resources">Sparse Resources</li>
                                    <li class="advanced" data-component="Dynamic Rendering (VK_KHR_dynamic_rendering)">Dynamic Rendering (VK_KHR_dynamic_rendering)</li>
                                    <li class="advanced" data-component="Memory Pools (Advanced vk-mem management)">Memory Pools (Advanced vk-mem management)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div class="info-column">
            <div class="info-tags-bar">
                <span class="tag-badge tag-required">Required</span>
                <span class="tag-badge tag-optional">Optional</span>
                <span class="tag-badge tag-advanced">Advanced</span>
                <span class="tag-badge tag-other">Other</span>
            </div>
            <div class="info-links-bar">
                <a href="#" id="ash-link" class="info-link" target="_blank" rel="noopener noreferrer">
                    Ash API <span class="external-link-icon">↗</span>
                </a>
                <a href="#" id="vulkan-spec-link" class="info-link" target="_blank" rel="noopener noreferrer">
                    Vulkan Spec <span class="external-link-icon">↗</span>
                </a>
            </div>
            <textarea id="info-text" readonly>Select a component from the tree to view its description.</textarea>
        </div>
    </div>
    <script>
        const componentInfo = {
            "Vulkan API": {
                description: "The root of the Vulkan graphics API, providing low-level access to GPU hardware for rendering.",
                ashPath: "index.html",
                vulkanAnchor: "#vulkan"
            },
            "Instance": {
                description: "The Vulkan instance is the connection between the application and the Vulkan library, managing global state.",
                ashPath: "vk/struct.Instance.html",
                vulkanAnchor: "#initialization-instances"
            },
            "Validation Layers": {
                description: "Optional layers for debugging and validating Vulkan API usage, useful during development.",
                vulkanAnchor: "#debugging-validation-layers"
            },
            "Debug Utilities (VK_EXT_debug_utils)": {
                description: "Extension for advanced debugging, allowing custom error messages and callbacks.",
                ashPath: "extensions/ext/struct.DebugUtils.html",
                vulkanAnchor: "#VK_EXT_debug_utils"
            },
            "Instance Extensions": {
                description: "Extensions to the Vulkan instance, enabling additional functionality like surface creation."
            },
            "VK_KHR_surface": {
                description: "Extension for creating a surface to render to a window or display.",
                ashPath: "extensions/khr/struct.Surface.html",
                vulkanAnchor: "#VK_KHR_surface"
            },
            "VK_EXT_debug_utils (Instance Extension)": {
                description: "Instance-level functions for the VK_EXT_debug_utils extension.",
                ashPath: "extensions/ext/struct.DebugUtils.html",
                vulkanAnchor: "#VK_EXT_debug_utils"
            },
            "Physical Devices": {
                description: "Represents the physical GPUs available, queried for properties and features.",
                ashPath: "vk/struct.PhysicalDevice.html",
                vulkanAnchor: "#devsandqueues-physical-device-enumeration"
            },
            "Device Features": {
                description: "Specific capabilities of a physical device, like texture compression or geometry shaders.",
                ashPath: "vk/struct.PhysicalDeviceFeatures.html",
                vulkanAnchor: "#features"
            },
            "Device Extensions": {
                description: "Extensions for the logical device, enabling features like swapchains."
            },
            "VK_KHR_swapchain": {
                description: "Extension for creating swapchains, allowing presentation of rendered images.",
                ashPath: "extensions/khr/struct.Swapchain.html",
                vulkanAnchor: "#VK_KHR_swapchain"
            },
            "VK_KHR_multisampling": {
                description: "Information about multisampling capabilities, often queried via PhysicalDeviceFeatures.",
                vulkanAnchor: "#primsrast-multisampling"
            },
            "Logical Device": {
                description: "An abstraction of a physical device, managing queues and resources for rendering.",
                ashPath: "vk/struct.Device.html",
                vulkanAnchor: "#devsandqueues-logical"
            },
            "Queues": {
                description: "Handles for submitting commands to the GPU, including graphics and presentation.",
                ashPath: "vk/struct.Queue.html",
                vulkanAnchor: "#devsandqueues-queues"
            },
            "Graphics Queue": { description: "Queue for submitting graphics and compute commands, essential for rendering." },
            "Present Queue": { description: "Queue for presenting rendered images to the surface, required for display." },
            "Command Pools": {
                description: "Manages memory for command buffers, used to record rendering commands.",
                ashPath: "vk/struct.CommandPool.html",
                vulkanAnchor: "#commandbuffers-pools"
            },
            "Memory Management": { description: "Handles allocation and management of GPU memory for resources." },
            "Vulkan Memory Allocator (vk-mem)": {
                description: "A library simplifying memory allocation for Vulkan resources."
            },
            "Surface": {
                description: "A platform-specific object representing a window or display for rendering.",
                ashPath: "extensions/khr/struct.Surface.html",
                vulkanAnchor: "#WSI_surface"
            },
            "VkSurfaceKHR (Platform-specific, e.g., Win32, XCB)": {
                description: "The surface object created for a specific window system (e.g., Win32, XCB).",
                ashPath: "extensions/khr/struct.Surface.html",
                vulkanAnchor: "#WSI_surface"
            },
            "Swapchain": {
                description: "Manages a queue of images for rendering and presenting to the surface.",
                ashPath: "extensions/khr/struct.Swapchain.html",
                vulkanAnchor: "#WSI_swapchain"
            },
            "Swapchain Images": { description: "Images managed by the swapchain, used as render targets." },
            "Image Views (Swapchain)": {
                description: "Views of swapchain images, specifying how they are accessed for rendering or presentation.",
                ashPath: "vk/struct.ImageView.html",
                vulkanAnchor: "#resources-image-views"
            },
            "Framebuffers": {
                description: "Collections of image views used as render targets for a render pass.",
                ashPath: "vk/struct.Framebuffer.html",
                vulkanAnchor: "#renderpass-framebuffers"
            },
            "Render Pass": {
                description: "Defines a sequence of rendering operations, including attachments and subpasses.",
                ashPath: "vk/struct.RenderPass.html",
                vulkanAnchor: "#renderpass"
            },
            "Attachments": { description: "Images (e.g., color, depth) used as inputs or outputs in a render pass." },
            "Color Attachment (Swapchain Image)": { description: "The primary render target for 2D rendering, typically a swapchain image." },
            "Depth/Stencil Attachment": { description: "Optional attachment for depth testing or stencil operations in 2D." },
            "Subpasses": { description: "Individual rendering stages within a render pass, defining attachment usage." },
            "Dependencies": { description: "Rules for synchronizing subpasses, ensuring correct rendering order." },
            "Descriptor Set Layouts": {
                description: "Defines the structure of descriptor sets for resource binding.",
                ashPath: "vk/struct.DescriptorSetLayout.html",
                vulkanAnchor: "#descriptorsets-layout"
            },
            "Descriptor Pools": {
                description: "Manages memory for allocating descriptor sets.",
                ashPath: "vk/struct.DescriptorPool.html",
                vulkanAnchor: "#descriptorsets-pools"
            },
            "Pipeline": {
                description: "Configures the GPU’s rendering pipeline, including shaders and state.",
                ashPath: "vk/struct.Pipeline.html",
                vulkanAnchor: "#pipelines"
            },
            "Shader Modules": {
                description: "Compiled SPIR-V shaders for vertex and fragment processing.",
                ashPath: "vk/struct.ShaderModule.html",
                vulkanAnchor: "#shaders-shader-modules"
            },
            "Vertex Shader (2D transformations)": { description: "Processes 2D vertex data, applying transformations like scaling or rotation." },
            "Fragment Shader (Texture sampling, color)": { description: "Samples textures and computes pixel colors for 2D rendering." },
            "Pipeline Layout": {
                description: "Defines resources (descriptors, push constants) accessible to shaders.",
                ashPath: "vk/struct.PipelineLayout.html",
                vulkanAnchor: "#pipelines-layout"
            },
            "Descriptor Sets": {
                description: "Binds resources like textures or buffers to shaders.",
                ashPath: "vk/struct.DescriptorSet.html",
                vulkanAnchor: "#descriptorsets-sets"
            },
            "Push Constants (Transformations, colors)": {
                description: "Small, fast data (e.g., matrices, colors) passed to shaders.",
                vulkanAnchor: "#pipelines-pushconstants"
            },
            "Graphics State": { description: "Configures fixed-function stages like rasterization and blending." },
            "Vertex Input (2D geometry)": { description: "Defines how 2D vertex data is fed into the pipeline." },
            "Rasterization": { description: "Converts 2D geometry into fragments for pixel processing." },
            "Color Blending (Alpha blending)": { description: "Combines fragment colors, enabling transparency via alpha blending." },
            "Depth/Stencil Testing": { description: "Optional testing for depth or stencil, rarely used in 2D." },
            "Multisampling": { description: "Reduces aliasing via multiple samples per pixel, optional for 2D." },
            "Dynamic State (Viewport, Scissor)": { description: "Dynamically adjustable states like viewport size, optional for flexibility." },
            "Pipeline Cache": {
                description: "Stores compiled pipelines for faster recreation, optional for performance.",
                ashPath: "vk/struct.PipelineCache.html",
                vulkanAnchor: "#pipelines-cache"
            },
            "Resources": { description: "Manages GPU resources like buffers and images for rendering." },
            "Buffers": {
                description: "Memory for storing vertex, index, or uniform data.",
                ashPath: "vk/struct.Buffer.html",
                vulkanAnchor: "#resources-buffers"
            },
            "Vertex Buffer (2D geometry)": { description: "Stores 2D vertex data like positions and texture coordinates." },
            "Index Buffer (Triangles/Quads)": { description: "Defines triangle or quad connectivity for 2D geometry." },
            "Uniform Buffer (Transformations, colors)": { description: "Stores per-draw data like transformation matrices or colors." },
            "Images": {
                description: "GPU memory for storing textures or render targets.",
                ashPath: "vk/struct.Image.html",
                vulkanAnchor: "#resources-images"
            },
            "Texture Images (Sprites, Atlas)": { description: "Images for 2D sprites or texture atlases, sampled in shaders." },
            "Image Views (General Textures)": {
                description: "Views of texture images, specifying how they are accessed for sampling.",
                ashPath: "vk/struct.ImageView.html",
                vulkanAnchor: "#resources-image-views"
            },
            "Depth/Stencil Image": { description: "Optional image for depth or stencil data, rarely used in 2D." },
            "Samplers (Texture sampling)": {
                description: "Defines how textures are sampled (e.g., filtering, wrapping) in shaders.",
                ashPath: "vk/struct.Sampler.html",
                vulkanAnchor: "#samplers"
            },
            "Synchronization": { description: "Mechanisms to coordinate GPU and CPU operations." },
            "Semaphores (Image acquisition, rendering)": {
                description: "Synchronizes rendering and presentation, e.g., for swapchain images.",
                ashPath: "vk/struct.Semaphore.html",
                vulkanAnchor: "#synchronization-semaphores"
            },
            "Fences (CPU-GPU sync)": {
                description: "Synchronizes CPU and GPU, ensuring commands complete.",
                ashPath: "vk/struct.Fence.html",
                vulkanAnchor: "#synchronization-fences"
            },
            "Events": {
                description: "Fine-grained synchronization within command buffers, optional for complex cases.",
                ashPath: "vk/struct.Event.html",
                vulkanAnchor: "#synchronization-events"
            },
            "Command Buffers": {
                description: "Records sequences of rendering commands for submission to the GPU.",
                ashPath: "vk/struct.CommandBuffer.html",
                vulkanAnchor: "#commandbuffers"
            },
            "Primary Command Buffers": { description: "Main command buffers submitted to queues for rendering." },
            "Secondary Command Buffers": { description: "Reusable command buffers for subroutines, optional for modularity." },
            "Recording Operations": { description: "Commands recorded into buffers, like binding resources or drawing." },
            "Bind Pipeline": { description: "Binds the rendering pipeline to a command buffer." },
            "Bind Descriptor Sets": { description: "Binds descriptor sets to make resources available to shaders." },
            "Bind Vertex/Index Buffers": { description: "Binds vertex and index buffers for geometry rendering." },
            "Draw Commands": { description: "Issues draw calls to render 2D geometry." },
            "Image Layout Transitions": { description: "Changes image layouts (e.g., for rendering or sampling)." },
            "Pipeline Barriers": {
                description: "Synchronizes access to resources between pipeline stages.",
                vulkanAnchor: "#synchronization-pipeline-barriers"
            },
            "Pipeline Stages (Vertex, Fragment)": { description: "Stages of the pipeline (e.g., vertex, fragment) for synchronization." },
            "Memory Barriers": { description: "Ensures correct ordering of memory operations." },
            "Advanced Features": { description: "Optional features for advanced 2D rendering effects." },
            "Post-Processing": { description: "Additional render passes for effects like blur or color grading." },
            "Render Targets": { description: "Intermediate images for post-processing or multi-pass rendering." },
            "Compute Shaders": { description: "Shaders for general-purpose GPU computing, used in advanced effects." },
            "Sparse Resources": { description: "Optimizes memory usage for large textures, optional for efficiency." },
            "Dynamic Rendering (VK_KHR_dynamic_rendering)": {
                description: "Modern rendering approach without render passes, for advanced use.",
                vulkanAnchor: "#VK_KHR_dynamic_rendering"
            },
            "Memory Pools (Advanced vk-mem management)": { description: "Advanced memory allocation strategies for performance." }
        };

        const ASH_BASE_URL = "https://docs.rs/ash/latest/ash/";
        const VULKAN_SPEC_BASE_URL = "https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html";

        let currentSelectedItemLi = null;
        const barColors = ['#637C8A', '#88CDF5'];

        let treeColumnRef, combinedStickyHeaderRef, stickyHeadersContainerRef, treeContentWrapperRef, branchBarRef;
        let finalStickyPathLIs = [];

        function clearAllHighlights() {
            document.querySelectorAll('.tree-content-wrapper li').forEach(liEl => {
                liEl.classList.remove('selected-item-dark-li');
                liEl.classList.remove('parent-highlight-li');
            });
        }

        function applyParentHighlight(liElement) {
            liElement.classList.add('parent-highlight-li');
            const childUls = liElement.querySelectorAll(':scope > ul');
            childUls.forEach(ul => {
                const childrenLis = ul.querySelectorAll(':scope > li');
                childrenLis.forEach(childLi => {
                    applyParentHighlight(childLi);
                });
            });
        }

        function updateBranchIndicatorBar() {
            const barArea = branchBarRef;
            const treeContentWrapper = treeContentWrapperRef;

            if (!barArea || !treeContentWrapper) return;
            const treeRootUl = treeContentWrapper.querySelector('ul');
            if (!treeRootUl) return;

            barArea.innerHTML = '';

            const firstTopLevelLi = treeRootUl.querySelector(':scope > li');
            if (!firstTopLevelLi) return;

            const mainBranchesParentUl = firstTopLevelLi.querySelector(':scope > ul');
            const wrapperPaddingTop = parseFloat(getComputedStyle(treeContentWrapper).paddingTop) || 0;

            if (!mainBranchesParentUl) {
                const segment = document.createElement('div');
                segment.classList.add('bar-segment');
                segment.style.top = firstTopLevelLi.offsetTop + 'px';
                segment.style.height = firstTopLevelLi.offsetHeight + 'px';
                segment.style.backgroundColor = barColors[0];
                barArea.appendChild(segment);
            } else {
                const mainBranchLis = Array.from(mainBranchesParentUl.children).filter(node => node.tagName === 'LI');
                mainBranchLis.forEach((li, index) => {
                    const segment = document.createElement('div');
                    segment.classList.add('bar-segment');
                    segment.style.top = li.offsetTop + 'px';
                    segment.style.height = li.offsetHeight + 'px';
                    segment.style.backgroundColor = barColors[index % barColors.length];
                    barArea.appendChild(segment);
                });
            }
            barArea.style.height = treeContentWrapper.scrollHeight + 'px';
        }

        function findStickyPathRecursive(currentUl, currentPathCandidate, combinedHeaderRectTop) {
            const lis = Array.from(currentUl.children).filter(node => node.tagName === 'LI');

            for (const li of lis) {
                const itemRow = li.querySelector(':scope > .tree-item-row');
                if (!itemRow) continue;

                const childUl = li.querySelector(':scope > ul');
                const isLiActuallyExpanded = childUl && childUl.style.display !== 'none';

                const itemRowRect = itemRow.getBoundingClientRect();
                const liRect = li.getBoundingClientRect();

                // Buffer to prevent flickering
                const isHeaderScrolledOff = itemRowRect.top < combinedHeaderRectTop - 5;
                const isContentStillVisible = liRect.bottom > combinedHeaderRectTop + 5;

                if (isHeaderScrolledOff && isContentStillVisible) {
                    currentPathCandidate.push(li);
                    finalStickyPathLIs = [...currentPathCandidate];

                    if (isLiActuallyExpanded) {
                        findStickyPathRecursive(childUl, currentPathCandidate, combinedHeaderRectTop);
                    }
                    currentPathCandidate.pop();
                }
            }
        }

        function updateStickyHeaders() {
            if (!treeColumnRef || !stickyHeadersContainerRef || !treeContentWrapperRef || !combinedStickyHeaderRef) {
                return;
            }

            const combinedHeaderRect = combinedStickyHeaderRef.getBoundingClientRect();
            stickyHeadersContainerRef.innerHTML = '';

            finalStickyPathLIs = [];
            const rootUl = treeContentWrapperRef.querySelector(':scope > ul');
            if (rootUl) {
                findStickyPathRecursive(rootUl, [], combinedHeaderRect.top);
            }

            if (finalStickyPathLIs.length > 0) {
                combinedStickyHeaderRef.style.visibility = 'visible';
                const firstPathOriginalItemRow = finalStickyPathLIs[0].querySelector(':scope > .tree-item-row');
                if (firstPathOriginalItemRow) {
                    combinedStickyHeaderRef.style.height = firstPathOriginalItemRow.offsetHeight + 'px';
                } else {
                    combinedStickyHeaderRef.style.height = 'auto';
                }
            } else {
                combinedStickyHeaderRef.style.visibility = 'hidden';
                combinedStickyHeaderRef.style.height = '0px';
                return;
            }

            const pathTexts = finalStickyPathLIs.map(li => {
                const contentSpan = li.querySelector(':scope > .tree-item-row > .tree-item-content');
                return contentSpan ? contentSpan.textContent.trim() : '';
            });
            const fullPathText = pathTexts.join(' > ');

            const firstPathElement = finalStickyPathLIs[0];
            const originalItemRow = firstPathElement.querySelector(':scope > .tree-item-row');
            const originalItemContent = firstPathElement.querySelector(':scope > .tree-item-row > .tree-item-content');

            if (originalItemRow && originalItemContent) {
                const stickyHeaderDiv = document.createElement('div');
                stickyHeaderDiv.classList.add('sticky-header-item');
                stickyHeaderDiv.style.height = originalItemRow.offsetHeight + 'px';

                const stickyTogglePlaceholder = document.createElement('span');
                stickyTogglePlaceholder.className = 'tree-toggle';
                stickyTogglePlaceholder.innerHTML = ' ';
                stickyTogglePlaceholder.style.visibility = 'hidden';

                const stickyContentSpan = document.createElement('span');
                stickyContentSpan.className = originalItemContent.className;
                stickyContentSpan.classList.add('tree-item-content');
                stickyContentSpan.textContent = fullPathText;
                stickyContentSpan.title = fullPathText;

                let indentForStickyText = 0;
                const rootUlInWrapper = treeContentWrapperRef.querySelector(':scope > ul');
                if (rootUlInWrapper) {
                    indentForStickyText += parseFloat(window.getComputedStyle(rootUlInWrapper).paddingLeft) || 0;
                }

                let el = firstPathElement.parentElement;
                while (el && el !== rootUlInWrapper && el !== treeContentWrapperRef) {
                    if (el.tagName === 'UL' && el.parentElement && el.parentElement.tagName === 'LI') {
                        indentForStickyText += parseFloat(window.getComputedStyle(el).paddingLeft) || 0;
                    }
                    el = el.parentElement;
                }

                const toggleElement = firstPathElement.querySelector(':scope > .tree-item-row > .tree-toggle');
                if (toggleElement) {
                    indentForStickyText += toggleElement.offsetWidth + (parseFloat(window.getComputedStyle(toggleElement).marginRight) || 0);
                }

                let paddingLeftForStickyDiv = indentForStickyText;
                if (toggleElement) {
                    paddingLeftForStickyDiv -= (toggleElement.offsetWidth + (parseFloat(window.getComputedStyle(toggleElement).marginRight) || 0));
                }

                stickyHeaderDiv.style.paddingLeft = paddingLeftForStickyDiv + 'px';

                stickyHeaderDiv.appendChild(stickyTogglePlaceholder);
                stickyHeaderDiv.appendChild(stickyContentSpan);
                stickyHeadersContainerRef.appendChild(stickyHeaderDiv);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            treeColumnRef = document.querySelector('.tree-column');
            combinedStickyHeaderRef = document.querySelector('.combined-sticky-header');
            stickyHeadersContainerRef = combinedStickyHeaderRef.querySelector('.sticky-headers-container');
            treeContentWrapperRef = document.querySelector('.tree-content-wrapper');
            branchBarRef = document.querySelector('.branch-indicator-bar-area');

            if (!treeColumnRef || !treeContentWrapperRef || !stickyHeadersContainerRef || !branchBarRef || !combinedStickyHeaderRef) {
                console.error("DOM elements for tree/sticky functionality not found.");
                return;
            }

            const allTagBadges = document.querySelectorAll('.info-tags-bar .tag-badge');
            const ashLinkElement = document.getElementById('ash-link');
            const vulkanSpecLinkElement = document.getElementById('vulkan-spec-link');

            const allTreeLIs = treeContentWrapperRef.querySelectorAll('li');

            allTreeLIs.forEach(li => {
                const originalTextNodes = Array.from(li.childNodes).filter(node => node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '');
                const originalText = originalTextNodes.length > 0 ? originalTextNodes[0].nodeValue.trim() : 'Error: No text';

                const dataComponent = li.getAttribute('data-component');
                const originalLiClasses = li.className.split(' ');
                let categoryClassForText = '';
                let categoryClassForTag = '';

                if (originalLiClasses.includes('essential')) {
                    categoryClassForText = 'essential-text';
                    categoryClassForTag = 'tag-required';
                } else if (originalLiClasses.includes('secondary')) {
                    categoryClassForText = 'secondary-text';
                    categoryClassForTag = 'tag-optional';
                } else if (originalLiClasses.includes('advanced')) {
                    categoryClassForText = 'advanced-text';
                    categoryClassForTag = 'tag-advanced';
                } else if (originalLiClasses.includes('other')) {
                    categoryClassForText = 'other-text';
                    categoryClassForTag = 'tag-other';
                }

                const itemRow = document.createElement('div');
                itemRow.classList.add('tree-item-row');
                const toggle = document.createElement('span');
                toggle.classList.add('tree-toggle');
                const contentSpan = document.createElement('span');
                contentSpan.classList.add('tree-item-content');
                if (categoryClassForText) {
                    contentSpan.classList.add(categoryClassForText);
                }
                contentSpan.textContent = originalText;
                if (categoryClassForTag) {
                    contentSpan.dataset.tagClass = categoryClassForTag;
                }
                itemRow.appendChild(toggle);
                itemRow.appendChild(contentSpan);
                const childUl = li.querySelector(':scope > ul');
                while (li.firstChild) {
                    if (li.firstChild.nodeName === 'UL') break;
                    li.removeChild(li.firstChild);
                }
                if (li.firstChild && li.firstChild.nodeName === 'UL') {
                    li.insertBefore(itemRow, li.firstChild);
                } else {
                    li.appendChild(itemRow);
                }
                if (childUl) {
                    childUl.style.display = 'block';
                }

                if (dataComponent) {
                    contentSpan.addEventListener('click', (event) => {
                        event.stopPropagation();
                        clearAllHighlights();
                        applyParentHighlight(li);
                        li.classList.add('selected-item-dark-li');
                        currentSelectedItemLi = li;

                        const component = dataComponent;
                        const componentData = componentInfo[component] || {};
                        const info = componentData.description ? componentData : { description: `No information available for "${component}".` };

                        const textArea = document.getElementById('info-text');
                        textArea.value = `${component}\n\n${info.description}`;

                        allTagBadges.forEach(badge => badge.style.display = 'none');
                        const tagClassToShow = contentSpan.dataset.tagClass;
                        if (tagClassToShow) {
                            const activeTag = document.querySelector(`.info-tags-bar .${tagClassToShow}`);
                            if (activeTag) {
                                activeTag.style.display = 'inline-flex';
                            }
                        }

                        if (componentData.ashPath && ashLinkElement) {
                            ashLinkElement.href = ASH_BASE_URL + componentData.ashPath;
                            ashLinkElement.style.display = 'inline-flex';
                        } else if (ashLinkElement) {
                            ashLinkElement.style.display = 'none';
                        }

                        if (vulkanSpecLinkElement) {
                            if (componentData.vulkanAnchor) {
                                vulkanSpecLinkElement.href = VULKAN_SPEC_BASE_URL + componentData.vulkanAnchor;
                                vulkanSpecLinkElement.style.display = 'inline-flex';
                            } else if (componentData.vulkanPath) {
                                vulkanSpecLinkElement.href = componentData.vulkanPath;
                                vulkanSpecLinkElement.style.display = 'inline-flex';
                            } else {
                                vulkanSpecLinkElement.style.display = 'none';
                            }
                        }
                    });
                }

                const nestedUl = li.querySelector(':scope > ul');
                if (nestedUl) {
                    toggle.textContent = '[-]';
                    toggle.addEventListener('click', (event) => {
                        event.stopPropagation();
                        const isCollapsed = nestedUl.style.display === 'none';
                        nestedUl.style.display = isCollapsed ? 'block' : 'none';
                        toggle.textContent = isCollapsed ? '[-]' : '[+]';
                        requestAnimationFrame(() => {
                            updateBranchIndicatorBar();
                            updateStickyHeaders();
                        });
                    });
                } else {
                    toggle.innerHTML = ' ';
                    toggle.style.cursor = 'default';
                    toggle.style.visibility = 'hidden';
                }
            });

            updateBranchIndicatorBar();
            updateStickyHeaders();

            let lastScrollTop = treeColumnRef.scrollTop;
            treeColumnRef.addEventListener('scroll', () => {
                const currentScrollTop = treeColumnRef.scrollTop;
                if (Math.abs(currentScrollTop - lastScrollTop) > 5) { // Debounce small scrolls
                    requestAnimationFrame(() => {
                        updateStickyHeaders();
                        lastScrollTop = currentScrollTop;
                    });
                }
            });
            window.addEventListener('resize', () => {
                requestAnimationFrame(() => {
                    updateBranchIndicatorBar();
                    updateStickyHeaders();
                });
            });
        });
    </script>
</body>
</html>